{
    "docs": [
        {
            "location": "/", 
            "text": "PlinkerRPC PHP client/server allows you to securely execute generic PHP \ncode and components on remote sites, while maintaining the feel of a local method call.\n\n\nComponents\n\n\nEach component is a composer package, you can find them \non packagist\n.\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\nVersion\n\n\n\n\n\n\n\n\n\n\ncore\n\n\nRequired base component which contains the client and server.\n\n\n\n\n\n\n\n\nasterisk\n\n\nAn Asterisk component which hooks into the Asterisk Management Interface on remote systems.\n\n\n\n\n\n\n\n\nbase91\n\n\nA core component, which base91 encodes the payload.\n\n\n\n\n\n\n\n\ncron\n\n\nA cron component which allows you to read and control cron tasks.\n\n\n\n\n\n\n\n\nfiles\n\n\nRead and write files on remote systems.\n\n\n\n\n\n\n\n\niptables\n\n\nControl IPtables on remote systems, mainly for purpose of port forwarding.\n\n\n\n\n\n\n\n\nlxc\n\n\nWIP: An older/deprecated component which controls LXC1.0 containers.\n\n\n\n\n\n\n\n\nnginx\n\n\nManage nginx as a reverse proxy.\n\n\n\n\n\n\n\n\nredbean\n\n\nRedBeanPHP component which will enable you to directly manage databases on remote sites.\n\n\n\n\n\n\n\n\nsystem\n\n\nA system component which gives you access to server information.\n\n\n\n\n\n\n\n\ntasks\n\n\nThe tasks component allows you to write code based tasks which are completed by a daemon, this could allow you to create a single interface to control a cluster of servers tasks.\n\n\n\n\n\n\n\n\ntest\n\n\nA test component which simply returns back what you sent, for testing/example purposes.\n\n\n\n\n\n\n\n\n\n\n\n\nDid you know?\n\n\nPlinkerRPC PHP client/server is also \navailable as a C extension\n which can be installed with Zephir.\n\n\n\n\n\n\nDevelopment Repository\n\n\nThe development repository is used to develop the entire project to make it easy to work on many parts at the same time without forgetting what was done,\nit contains a bash script which will commit and do semantic versioning for each sub component.\n\n\nInstalling\n\n\n\n\ngit clone git@github.com:plinker-rpc/development.git .\n\n\ncomposer install\n\n\n\n\nCommitting Changes\n\n\nBash scripts have been added to automate this, do not do it manually.\n\n\n\n\nbash ./commit.sh \nA really informative commit message.\n\n\n\n\nThe above 1 liner will ask:\n\n\nDo you wish to [c]ommit, [d]eploy or [e]xit?\n\n\n\n\nIf you choose commit, it will push your changes and docs to github.\n\n\nIf you choose deploy, it will ask: \nWhich type of changes has been done: [p]atch, [m]inor, [M]ajor?\n, upon choice it will increment the semantic version, tag then push your changes and docs to github.\n\n\n\n\nbash ./dev_mkdocs.sh\n is used to write docs with hot reloading at \nhttp://127.0.0.0:8000\n\n\nNew Components\n\n\nTo create a new component simply edit the \ncomponent-generator.php\n file then run it.\n\n\nIt will generate the following structure in vendor, ready to start \ncreating your component package.\n\n\ncomponent \u2510\n          \u251c\u2500\u2500 src\n          \u2502   \u251c\u2500\u2500 Component.php\n          \u251c\u2500\u2500 tests\n          \u2502   \u251c\u2500\u2500 fixtures\n          \u2502   \u251c\u2500\u2500 ComponentTest.php\n          \u2502   \u2514\u2500\u2500 bootstrap.php\n          \u251c\u2500\u2500 .gitignore\n          \u251c\u2500\u2500 .scrutinizer.yml\n          \u251c\u2500\u2500 .styleci.yml\n          \u251c\u2500\u2500 .travis.yml\n          \u251c\u2500\u2500 CONTRIBUTING.md\n          \u251c\u2500\u2500 LICENSE\n          \u251c\u2500\u2500 phpunit.xml\n          \u251c\u2500\u2500 README.md\n          \u2514\u2500\u2500 composer.json\n\n\n\n\n\nWhen ready:\n\n\n\n\nMake sure \nREADME.md\n conforms to docs structure.\n\n\nCreate a github repository in the organisation, push your changes.\n\n\nAdd the new component to \ncommit.sh\n, \ndev_mkdocs.sh\n and \nmkdocs.sh\n component arrays.\n\n\nRun \nbash ./commit.sh \nInital Commit\n\n\nAdd to packagist.\n\n\nEnable on \nStyleCI\n, \nTravisCI\n, \nScrutinizerCI\n.\n\n\n\n\nRequest a Component\n\n\nIf you've got an idea for a component and would like to see it added, feel free to \nopen an issue\n.\n\n\nDevelopment Encouragement\n\n\nIf you use this project and make money from it or want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed throughout the documentation and on each github repository, contact me at \nhttps://cherone.co.uk\n for further details.", 
            "title": "Home"
        }, 
        {
            "location": "/#components", 
            "text": "Each component is a composer package, you can find them  on packagist .     Component  Description  Version      core  Required base component which contains the client and server.     asterisk  An Asterisk component which hooks into the Asterisk Management Interface on remote systems.     base91  A core component, which base91 encodes the payload.     cron  A cron component which allows you to read and control cron tasks.     files  Read and write files on remote systems.     iptables  Control IPtables on remote systems, mainly for purpose of port forwarding.     lxc  WIP: An older/deprecated component which controls LXC1.0 containers.     nginx  Manage nginx as a reverse proxy.     redbean  RedBeanPHP component which will enable you to directly manage databases on remote sites.     system  A system component which gives you access to server information.     tasks  The tasks component allows you to write code based tasks which are completed by a daemon, this could allow you to create a single interface to control a cluster of servers tasks.     test  A test component which simply returns back what you sent, for testing/example purposes.       Did you know?  PlinkerRPC PHP client/server is also  available as a C extension  which can be installed with Zephir.", 
            "title": "Components"
        }, 
        {
            "location": "/#development-repository", 
            "text": "The development repository is used to develop the entire project to make it easy to work on many parts at the same time without forgetting what was done,\nit contains a bash script which will commit and do semantic versioning for each sub component.", 
            "title": "Development Repository"
        }, 
        {
            "location": "/#installing", 
            "text": "git clone git@github.com:plinker-rpc/development.git .  composer install", 
            "title": "Installing"
        }, 
        {
            "location": "/#committing-changes", 
            "text": "Bash scripts have been added to automate this, do not do it manually.   bash ./commit.sh  A really informative commit message.   The above 1 liner will ask:  Do you wish to [c]ommit, [d]eploy or [e]xit?   If you choose commit, it will push your changes and docs to github.  If you choose deploy, it will ask:  Which type of changes has been done: [p]atch, [m]inor, [M]ajor? , upon choice it will increment the semantic version, tag then push your changes and docs to github.   bash ./dev_mkdocs.sh  is used to write docs with hot reloading at  http://127.0.0.0:8000", 
            "title": "Committing Changes"
        }, 
        {
            "location": "/#new-components", 
            "text": "To create a new component simply edit the  component-generator.php  file then run it.  It will generate the following structure in vendor, ready to start \ncreating your component package.  component \u2510\n          \u251c\u2500\u2500 src\n          \u2502   \u251c\u2500\u2500 Component.php\n          \u251c\u2500\u2500 tests\n          \u2502   \u251c\u2500\u2500 fixtures\n          \u2502   \u251c\u2500\u2500 ComponentTest.php\n          \u2502   \u2514\u2500\u2500 bootstrap.php\n          \u251c\u2500\u2500 .gitignore\n          \u251c\u2500\u2500 .scrutinizer.yml\n          \u251c\u2500\u2500 .styleci.yml\n          \u251c\u2500\u2500 .travis.yml\n          \u251c\u2500\u2500 CONTRIBUTING.md\n          \u251c\u2500\u2500 LICENSE\n          \u251c\u2500\u2500 phpunit.xml\n          \u251c\u2500\u2500 README.md\n          \u2514\u2500\u2500 composer.json  When ready:   Make sure  README.md  conforms to docs structure.  Create a github repository in the organisation, push your changes.  Add the new component to  commit.sh ,  dev_mkdocs.sh  and  mkdocs.sh  component arrays.  Run  bash ./commit.sh  Inital Commit  Add to packagist.  Enable on  StyleCI ,  TravisCI ,  ScrutinizerCI .", 
            "title": "New Components"
        }, 
        {
            "location": "/#request-a-component", 
            "text": "If you've got an idea for a component and would like to see it added, feel free to  open an issue .", 
            "title": "Request a Component"
        }, 
        {
            "location": "/#development-encouragement", 
            "text": "If you use this project and make money from it or want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.", 
            "title": "Development Encouragement"
        }, 
        {
            "location": "/#sponsors", 
            "text": "Get your company or name listed throughout the documentation and on each github repository, contact me at  https://cherone.co.uk  for further details.", 
            "title": "Sponsors"
        }, 
        {
            "location": "/asterisk/", 
            "text": "Development halted\n\n\nThis component is no longer being actively developed, though bugs will be fixed if reported.\n\n\n\n\nAn Asterisk component which hooks into the Asterisk Management Interface (AMI) on remote systems. Using it adds addtional security as you can lock down AMI to listen on only on localhost.\n\n\nInstall\n\n\nRequire this package with composer using the following command:\n\n\n$ composer require plinker/asterisk\n\n\n\n\n\nClient\n\n\nCreating a client instance is done as follows:\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $server - URL to server listener.\n\n\n * @param string $config - server secret, and/or a additional component data\n\n\n */\n\n\n$client\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \nhttp://example.com/server.php\n,\n\n    \n[\n\n        \nsecret\n \n=\n \na secret password\n,\n\n        \ndatabase\n \n=\n \n[\n\n            \ndsn\n \n=\n \nmysql:host=127.0.0.1;dbname=asterisk\n,\n\n            \nusername\n \n=\n \n,\n\n            \npassword\n \n=\n \n,\n\n            \ndatabase\n \n=\n \n,\n\n            \nfreeze\n \n=\n \nfalse\n,\n\n            \ndebug\n \n=\n \nfalse\n\n        \n],\n\n        \nami\n \n=\n \n[\n\n            \nserver\n \n=\n \n127.0.0.1\n,\n\n            \nport\n \n=\n \n5038\n,\n\n            \nusername\n \n=\n \n,\n\n            \npassword\n \n=\n \n\n        \n]\n\n    \n]\n\n\n);\n\n\n\n// or using global function\n\n\n$client\n \n=\n \nplinker_client\n(\nhttp://example.com/server.php\n,\n \na secret password\n,\n \n[\n\n    \ndatabase\n \n=\n \n[\n\n        \ndsn\n \n=\n \nmysql:host=127.0.0.1;dbname=asterisk\n,\n\n        \nusername\n \n=\n \n,\n\n        \npassword\n \n=\n \n,\n\n        \ndatabase\n \n=\n \n,\n\n        \nfreeze\n \n=\n \nfalse\n,\n\n        \ndebug\n \n=\n \nfalse\n\n    \n],\n\n    \nami\n \n=\n \n[\n\n        \nserver\n \n=\n \n127.0.0.1\n,\n\n        \nport\n \n=\n \n5038\n,\n\n        \nusername\n \n=\n \n,\n\n        \npassword\n \n=\n \n\n    \n]\n\n\n]);\n\n\n\n\n\n\nMethods\n\n\nOnce setup, you call the class though its namespace to its method.\n\n\nCommand\n\n\nExecute ASM command.\n\n\nCall\n\n\n$result = $client-\nasterisk-\ncommand(\nsip show peers\n);\n\n\n\n\n\nResponse\n\n\n\n\n\n\n\n\nGet Queue\n\n\nConnect into AMI and issue asterisk command [queue show *].\n\n\nCall\n\n\n$result = $client-\nasterisk-\ngetQueue(\nfoo\n);\n\n\n\n\n\nResponse\n\n\n\n\n\n\n\n\nShow Channels\n\n\nConnect into AMI and issue asterisk command [core show channels].\n\n\nCall\n\n\n$result = $client-\nasterisk-\ncoreShowChannels();\n\n\n\n\n\nResponse\n\n\nArray\n(\n    \nactive_channels\n =\n 0,\n    \nactive_calls\n =\n 0,\n    \ncalls_processed\n =\n 0\n}\n\n\n\n\n\nAnd other methods see: \nvendor/asterisk/src/Asterisk.php\n\n\nTesting\n\n\nThere are no tests setup for this component.\n\n\nContributing\n\n\nPlease see \nCONTRIBUTING\n for details.\n\n\nSecurity\n\n\nIf you discover any security related issues, please contact me via \nhttps://cherone.co.uk\n instead of using the issue tracker.\n\n\nCredits\n\n\n\n\nLawrence Cherone\n\n\nAll Contributors\n\n\n\n\nDevelopment Encouragement\n\n\nIf you use this project and make money from it or want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed throughout the documentation and on each github repository, contact me at \nhttps://cherone.co.uk\n for further details.\n\n\nLicense\n\n\nThe MIT License (MIT). Please see \nLicense File\n for more information.\n\n\nSee \norganisations page\n for additional components.", 
            "title": "Asterisk"
        }, 
        {
            "location": "/asterisk/#install", 
            "text": "Require this package with composer using the following command:  $ composer require plinker/asterisk", 
            "title": "Install"
        }, 
        {
            "location": "/asterisk/#client", 
            "text": "Creating a client instance is done as follows:  ?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $server - URL to server listener.   * @param string $config - server secret, and/or a additional component data   */  $client   =   new   \\Plinker\\Core\\Client ( \n     http://example.com/server.php , \n     [ \n         secret   =   a secret password , \n         database   =   [ \n             dsn   =   mysql:host=127.0.0.1;dbname=asterisk , \n             username   =   , \n             password   =   , \n             database   =   , \n             freeze   =   false , \n             debug   =   false \n         ], \n         ami   =   [ \n             server   =   127.0.0.1 , \n             port   =   5038 , \n             username   =   , \n             password   =   \n         ] \n     ]  );  // or using global function  $client   =   plinker_client ( http://example.com/server.php ,   a secret password ,   [ \n     database   =   [ \n         dsn   =   mysql:host=127.0.0.1;dbname=asterisk , \n         username   =   , \n         password   =   , \n         database   =   , \n         freeze   =   false , \n         debug   =   false \n     ], \n     ami   =   [ \n         server   =   127.0.0.1 , \n         port   =   5038 , \n         username   =   , \n         password   =   \n     ]  ]);", 
            "title": "Client"
        }, 
        {
            "location": "/asterisk/#methods", 
            "text": "Once setup, you call the class though its namespace to its method.", 
            "title": "Methods"
        }, 
        {
            "location": "/asterisk/#command", 
            "text": "Execute ASM command.  Call  $result = $client- asterisk- command( sip show peers );  Response", 
            "title": "Command"
        }, 
        {
            "location": "/asterisk/#get-queue", 
            "text": "Connect into AMI and issue asterisk command [queue show *].  Call  $result = $client- asterisk- getQueue( foo );  Response", 
            "title": "Get Queue"
        }, 
        {
            "location": "/asterisk/#show-channels", 
            "text": "Connect into AMI and issue asterisk command [core show channels].  Call  $result = $client- asterisk- coreShowChannels();  Response  Array\n(\n     active_channels  =  0,\n     active_calls  =  0,\n     calls_processed  =  0\n}  And other methods see:  vendor/asterisk/src/Asterisk.php", 
            "title": "Show Channels"
        }, 
        {
            "location": "/asterisk/#testing", 
            "text": "There are no tests setup for this component.", 
            "title": "Testing"
        }, 
        {
            "location": "/asterisk/#contributing", 
            "text": "Please see  CONTRIBUTING  for details.", 
            "title": "Contributing"
        }, 
        {
            "location": "/asterisk/#security", 
            "text": "If you discover any security related issues, please contact me via  https://cherone.co.uk  instead of using the issue tracker.", 
            "title": "Security"
        }, 
        {
            "location": "/asterisk/#credits", 
            "text": "Lawrence Cherone  All Contributors", 
            "title": "Credits"
        }, 
        {
            "location": "/asterisk/#development-encouragement", 
            "text": "If you use this project and make money from it or want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.", 
            "title": "Development Encouragement"
        }, 
        {
            "location": "/asterisk/#sponsors", 
            "text": "Get your company or name listed throughout the documentation and on each github repository, contact me at  https://cherone.co.uk  for further details.", 
            "title": "Sponsors"
        }, 
        {
            "location": "/asterisk/#license", 
            "text": "The MIT License (MIT). Please see  License File  for more information.  See  organisations page  for additional components.", 
            "title": "License"
        }, 
        {
            "location": "/base91/", 
            "text": "A core component, which base91 encodes the payload, you do not need to include it as its included with core.\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Base91"
        }, 
        {
            "location": "/core/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute generic PHP components on remote systems, while maintaining the feel of a local method call.\n\n\nDocs:\n \nhttps://plinker-rpc.github.io/core\n\n\nNew changes in version 3 include:\n\n\n\n\nNow compaible with \nPHP extension\n.\n\n\nBuilt-in core components and info method added so components can be discovered.\n\n\nOnly one client instance is now needed, made use of __get() to dynamically set component.\n\n\nUser defined components/classes, so you can call your own code.\n\n\nBoth request and response is encrypted and signed.\n\n\n\n\nInstall\n\n\nRequire this package with composer using the following command:\n\n\n$ composer require plinker/core\n\n\n\n\n\nAdditional Setup\n\n\nThis component does not require any additional setup.\n\n\nClient\n\n\nCreating a client instance is done as follows:\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $server - URL to server listener.\n\n\n * @param string $config - server secret, and/or a additional component data\n\n\n */\n\n\n$client\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \nhttp://example.com/server.php\n,\n\n    \n[\n\n        \nsecret\n \n=\n \na secret password\n,\n\n    \n]\n\n\n);\n\n\n\n// or using global function\n\n\n$client\n \n=\n \nplinker_client\n(\nhttp://example.com/server.php\n,\n \na secret password\n);\n\n\n\n\n\n\nServer\n\n\nCreating a server listener is done as follows:\n\n\nOptional features:\n\n\n\n\nSet a secret, which all clients will require. \n\n\nLock down to specific client IP addresses for addtional security.\n\n\nDefine your own classes in the \nclasses\n array then access like above \n$client-\nclass-\nmethod()\n, which can interface out of scope components or composer packages.\n\n\nDefine addtional key values for database connections etc, or you could pass the parameters through the client connection.\n\n\n\n\n\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker server.\n\n\n */\n\n\nif\n \n(\nisset\n(\n$_SERVER\n[\nHTTP_PLINKER\n]))\n \n{\n\n    \n// init plinker server\n\n    \necho\n \n(\nnew\n \n\\Plinker\\Server\n([\n\n        \nsecret\n \n=\n \na secret password\n,\n\n        \nallowed_ips\n \n=\n \n[\n\n            \n127.0.0.1\n\n        \n],\n\n        \nclasses\n \n=\n \n[\n\n            \ntest\n \n=\n \n[\n\n                \n// path to file\n\n                \nclasses/test.php\n,\n\n                \n// addtional key/values\n\n                \n[\n\n                    \nkey\n \n=\n \nvalue\n\n                \n]\n\n            \n],\n\n            \n// you can use namespaced classes\n\n            \nFoo\\\\Demo\n \n=\n \n[\n\n                \n// path to file\n\n                \nsome_class/demo.php\n,\n\n                \n// addtional key/values\n\n                \n[\n\n                    \nkey\n \n=\n \nvalue\n\n                \n]\n\n            \n],\n\n            \n// ...\n\n        \n]\n\n    \n]))\n-\nlisten\n();\n\n\n}\n\n\n\n\n\n\nMethods\n\n\nOnce setup, you call the class though its namespace to its method.\n\n\nInfo\n\n\nThe info method returns defined endpoint methods and their parameters.\n\n\nCall\n\n\n$result = $client-\ninfo();\n\n\n\n\n\nResponse\n\n\nArray\n(\n    [class] =\n Array\n        (\n            [Foo\\Demo] =\n Array\n                (\n                    [config] =\n Array\n                        (\n                            [key] =\n value\n                        )\n\n                    [methods] =\n Array\n                        (\n                            [config] =\n Array\n                                (\n                                )\n\n                            [this] =\n Array\n                                (\n                                )\n\n                            [test] =\n Array\n                                (\n                                    [0] =\n x\n                                    [1] =\n y\n                                )\n\n                        )\n\n                )\n\n        )\n\n)\n\n\n\n\n\nTesting\n\n\n$ composer \ntest\n\n\n\n\n\n\nContributing\n\n\nPlease see \nCONTRIBUTING\n for details.\n\n\nSecurity\n\n\nIf you discover any security related issues, please contact me via \nhttps://cherone.co.uk\n instead of using the issue tracker.\n\n\nCredits\n\n\n\n\nLawrence Cherone\n\n\nAll Contributors\n\n\n\n\nDevelopment Encouragement\n\n\nIf you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation \nhttps://www.paypal.me/lcherone\n, thanks.\n\n\nSponsors\n\n\nGet your company or name listed here.\n\n\nLicense\n\n\nThe MIT License (MIT). Please see \nLicense File\n for more information.\n\n\nSee \norganisations page\n for additional components.", 
            "title": "Core"
        }, 
        {
            "location": "/core/#install", 
            "text": "Require this package with composer using the following command:  $ composer require plinker/core", 
            "title": "Install"
        }, 
        {
            "location": "/core/#additional-setup", 
            "text": "This component does not require any additional setup.", 
            "title": "Additional Setup"
        }, 
        {
            "location": "/core/#client", 
            "text": "Creating a client instance is done as follows:  ?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $server - URL to server listener.   * @param string $config - server secret, and/or a additional component data   */  $client   =   new   \\Plinker\\Core\\Client ( \n     http://example.com/server.php , \n     [ \n         secret   =   a secret password , \n     ]  );  // or using global function  $client   =   plinker_client ( http://example.com/server.php ,   a secret password );", 
            "title": "Client"
        }, 
        {
            "location": "/core/#server", 
            "text": "Creating a server listener is done as follows:  Optional features:   Set a secret, which all clients will require.   Lock down to specific client IP addresses for addtional security.  Define your own classes in the  classes  array then access like above  $client- class- method() , which can interface out of scope components or composer packages.  Define addtional key values for database connections etc, or you could pass the parameters through the client connection.    ?php  require   vendor/autoload.php ;  /**   * Initialize plinker server.   */  if   ( isset ( $_SERVER [ HTTP_PLINKER ]))   { \n     // init plinker server \n     echo   ( new   \\Plinker\\Server ([ \n         secret   =   a secret password , \n         allowed_ips   =   [ \n             127.0.0.1 \n         ], \n         classes   =   [ \n             test   =   [ \n                 // path to file \n                 classes/test.php , \n                 // addtional key/values \n                 [ \n                     key   =   value \n                 ] \n             ], \n             // you can use namespaced classes \n             Foo\\\\Demo   =   [ \n                 // path to file \n                 some_class/demo.php , \n                 // addtional key/values \n                 [ \n                     key   =   value \n                 ] \n             ], \n             // ... \n         ] \n     ])) - listen ();  }", 
            "title": "Server"
        }, 
        {
            "location": "/core/#methods", 
            "text": "Once setup, you call the class though its namespace to its method.", 
            "title": "Methods"
        }, 
        {
            "location": "/core/#info", 
            "text": "The info method returns defined endpoint methods and their parameters.  Call  $result = $client- info();  Response  Array\n(\n    [class] =  Array\n        (\n            [Foo\\Demo] =  Array\n                (\n                    [config] =  Array\n                        (\n                            [key] =  value\n                        )\n\n                    [methods] =  Array\n                        (\n                            [config] =  Array\n                                (\n                                )\n\n                            [this] =  Array\n                                (\n                                )\n\n                            [test] =  Array\n                                (\n                                    [0] =  x\n                                    [1] =  y\n                                )\n\n                        )\n\n                )\n\n        )\n\n)", 
            "title": "Info"
        }, 
        {
            "location": "/core/#testing", 
            "text": "$ composer  test", 
            "title": "Testing"
        }, 
        {
            "location": "/core/#contributing", 
            "text": "Please see  CONTRIBUTING  for details.", 
            "title": "Contributing"
        }, 
        {
            "location": "/core/#security", 
            "text": "If you discover any security related issues, please contact me via  https://cherone.co.uk  instead of using the issue tracker.", 
            "title": "Security"
        }, 
        {
            "location": "/core/#credits", 
            "text": "Lawrence Cherone  All Contributors", 
            "title": "Credits"
        }, 
        {
            "location": "/core/#development-encouragement", 
            "text": "If you use this code and make money from it and want to show your appreciation,\nplease feel free to make a donation  https://www.paypal.me/lcherone , thanks.", 
            "title": "Development Encouragement"
        }, 
        {
            "location": "/core/#sponsors", 
            "text": "Get your company or name listed here.", 
            "title": "Sponsors"
        }, 
        {
            "location": "/core/#license", 
            "text": "The MIT License (MIT). Please see  License File  for more information.  See  organisations page  for additional components.", 
            "title": "License"
        }, 
        {
            "location": "/cron/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA cron component which allows you to read and control cron tasks.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/cron\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking remote calls.\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\ntry\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$config\n \n=\n \n[\n\n        \n// plinker connection | using tasks as to write in the correct .sqlite file\n\n        \nplinker\n \n=\n \n[\n\n            \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/cron/server.php\n,\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n        \n],\n\n\n        \n// optional config\n\n        \nconfig\n \n=\n \n[\n\n            \njournal\n \n=\n \n./crontab.journal\n,\n\n            \napply\n   \n=\n \nfalse\n\n        \n]\n\n    \n];\n\n\n    \n// init plinker endpoint client\n\n    \n$cron\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n        \n// where is the plinker server\n\n        \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n        \n// component namespace to interface to\n\n        \nCron\\Manager\n,\n\n\n        \n// keys\n\n        \n$config\n[\nplinker\n][\npublic_key\n],\n\n        \n$config\n[\nplinker\n][\nprivate_key\n],\n\n\n        \n// construct array which you pass to the component\n\n        \n$config\n[\nconfig\n]\n\n    \n);\n\n\n    \n// get crontab as-is\n\n    \necho\n \nh2\n$cron-\ncrontab()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ncrontab\n()\n.\n/pre\n;\n\n\n    \n// create a crontask\n\n    \necho\n \nh2\n$cron-\ncreate(\\\nMy Cron Task\\\n, \\\n* * * * * cd ~\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ncreate\n(\nMy Cron Task\n,\n \n* * * * * cd ~\n)\n.\n/pre\n;\n\n\n    \n// get cron task\n\n    \necho\n \nh2\n$cron-\nget(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nget\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// update cron task\n\n    \necho\n \nh2\n$cron-\nupdate(\\\nMy Cron Task\\\n, \\\n0 * * * * cd ~\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nupdate\n(\nMy Cron Task\n,\n \n0 * * * * cd ~\n)\n.\n/pre\n;\n\n\n    \n// get cron task\n\n    \necho\n \nh2\n$cron-\nget(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nget\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// delete cron task\n\n    \necho\n \nh2\n$cron-\ndelete(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ndelete\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// get cron task\n\n    \necho\n \nh2\n$cron-\nget(\\\nMy Cron Task\\\n)\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\nget\n(\nMy Cron Task\n)\n.\n/pre\n;\n\n\n    \n// drop cron task\n\n    \necho\n \nh2\n$cron-\ndrop()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ndrop\n()\n.\n/pre\n;\n\n\n    \n// get crontab as-is\n\n    \necho\n \nh2\n$cron-\ncrontab()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\ncrontab\n()\n.\n/pre\n;\n\n\n    \n// apply crontab\n\n    \necho\n \nh2\n$cron-\napply()\n/h2\n;\n\n    \necho\n \npre\n.\n$cron\n-\napply\n()\n.\n/pre\n;\n\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nexit\n(\nget_class\n(\n$e\n)\n.\n: \n.\n$e\n-\ngetMessage\n());\n\n\n}\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Its POST..\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n\n    \n/**\n\n\n     * Its Plinker!\n\n\n     */\n\n    \nif\n \n(\nisset\n(\n$_SERVER\n[\nHTTP_PLINKER\n]))\n \n{\n\n        \n// test its encrypted\n\n        \nfile_put_contents\n(\n./.plinker/encryption-proof.txt\n,\n \nprint_r\n(\n$_POST\n,\n \ntrue\n));\n\n\n        \n/**\n\n\n         * Define Plinker Config\n\n\n         */\n\n        \n$plinker\n \n=\n \n[\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n,\n\n            \n// optional config\n\n            \n/*\nconfig\n =\n [\n\n\n                // allowed ips, restrict access by ip\n\n\n                \nallowed_ips\n =\n [\n\n\n                    \n127.0.0.1\n\n\n                ]\n\n\n            ]*/\n\n        \n];\n\n\n        \n// init plinker server\n\n        \n$server\n \n=\n \nnew\n \n\\Plinker\\Core\\Server\n(\n\n            \n$_POST\n,\n\n            \n$plinker\n[\npublic_key\n],\n\n            \n$plinker\n[\nprivate_key\n],\n\n            \n(\narray\n)\n \n@\n$plinker\n[\nconfig\n]\n\n        \n);\n\n\n        \nexit\n(\n$server\n-\nexecute\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Cron"
        }, 
        {
            "location": "/cron/#making-remote-calls", 
            "text": "?php  require   ../../vendor/autoload.php ;  try   { \n\n     /**       * Plinker Config       */ \n     $config   =   [ \n         // plinker connection | using tasks as to write in the correct .sqlite file \n         plinker   =   [ \n             endpoint   =   http://127.0.0.1/examples/cron/server.php , \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp \n         ], \n\n         // optional config \n         config   =   [ \n             journal   =   ./crontab.journal , \n             apply     =   false \n         ] \n     ]; \n\n     // init plinker endpoint client \n     $cron   =   new   \\Plinker\\Core\\Client ( \n         // where is the plinker server \n         $config [ plinker ][ endpoint ], \n\n         // component namespace to interface to \n         Cron\\Manager , \n\n         // keys \n         $config [ plinker ][ public_key ], \n         $config [ plinker ][ private_key ], \n\n         // construct array which you pass to the component \n         $config [ config ] \n     ); \n\n     // get crontab as-is \n     echo   h2 $cron- crontab() /h2 ; \n     echo   pre . $cron - crontab () . /pre ; \n\n     // create a crontask \n     echo   h2 $cron- create(\\ My Cron Task\\ , \\ * * * * * cd ~\\ ) /h2 ; \n     echo   pre . $cron - create ( My Cron Task ,   * * * * * cd ~ ) . /pre ; \n\n     // get cron task \n     echo   h2 $cron- get(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - get ( My Cron Task ) . /pre ; \n\n     // update cron task \n     echo   h2 $cron- update(\\ My Cron Task\\ , \\ 0 * * * * cd ~\\ ) /h2 ; \n     echo   pre . $cron - update ( My Cron Task ,   0 * * * * cd ~ ) . /pre ; \n\n     // get cron task \n     echo   h2 $cron- get(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - get ( My Cron Task ) . /pre ; \n\n     // delete cron task \n     echo   h2 $cron- delete(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - delete ( My Cron Task ) . /pre ; \n\n     // get cron task \n     echo   h2 $cron- get(\\ My Cron Task\\ ) /h2 ; \n     echo   pre . $cron - get ( My Cron Task ) . /pre ; \n\n     // drop cron task \n     echo   h2 $cron- drop() /h2 ; \n     echo   pre . $cron - drop () . /pre ; \n\n     // get crontab as-is \n     echo   h2 $cron- crontab() /h2 ; \n     echo   pre . $cron - crontab () . /pre ; \n\n     // apply crontab \n     echo   h2 $cron- apply() /h2 ; \n     echo   pre . $cron - apply () . /pre ;  }   catch   ( \\Exception   $e )   { \n     exit ( get_class ( $e ) . :  . $e - getMessage ());  }   then the server part...  ?php  require   ../../vendor/autoload.php ;  /**   * Its POST..   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n\n     /**       * Its Plinker!       */ \n     if   ( isset ( $_SERVER [ HTTP_PLINKER ]))   { \n         // test its encrypted \n         file_put_contents ( ./.plinker/encryption-proof.txt ,   print_r ( $_POST ,   true )); \n\n         /**           * Define Plinker Config           */ \n         $plinker   =   [ \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp , \n             // optional config \n             /* config  =  [                  // allowed ips, restrict access by ip                   allowed_ips  =  [                       127.0.0.1                  ]              ]*/ \n         ]; \n\n         // init plinker server \n         $server   =   new   \\Plinker\\Core\\Server ( \n             $_POST , \n             $plinker [ public_key ], \n             $plinker [ private_key ], \n             ( array )   @ $plinker [ config ] \n         ); \n\n         exit ( $server - execute ()); \n     }  }   See the  organisations page  for additional components.", 
            "title": "Making remote calls."
        }, 
        {
            "location": "/files/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA files component which allows you to read and write files.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/files\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking remote calls.\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\ntry\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$config\n \n=\n \n[\n\n        \n// plinker connection | using tasks as to write in the correct .sqlite file\n\n        \nplinker\n \n=\n \n[\n\n            \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/cron/server.php\n,\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n        \n],\n\n\n        \n// optional config\n\n        \nconfig\n \n=\n \n[\n\n            \njournal\n \n=\n \n./crontab.journal\n,\n\n            \napply\n   \n=\n \nfalse\n\n        \n]\n\n    \n];\n\n\n    \n// init plinker endpoint client\n\n    \n$cron\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n        \n// where is the plinker server\n\n        \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n        \n// component namespace to interface to\n\n        \nFiles\\Manager\n,\n\n\n        \n// keys\n\n        \n$config\n[\nplinker\n][\npublic_key\n],\n\n        \n$config\n[\nplinker\n][\nprivate_key\n],\n\n\n        \n// construct array which you pass to the component\n\n        \n$config\n[\nconfig\n]\n\n    \n);\n\n\n    \n// todo!\n\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nexit\n(\nget_class\n(\n$e\n)\n.\n: \n.\n$e\n-\ngetMessage\n());\n\n\n}\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Its POST..\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n\n    \n/**\n\n\n     * Its Plinker!\n\n\n     */\n\n    \nif\n \n(\nisset\n(\n$_SERVER\n[\nHTTP_PLINKER\n]))\n \n{\n\n        \n// test its encrypted\n\n        \nfile_put_contents\n(\n./.plinker/encryption-proof.txt\n,\n \nprint_r\n(\n$_POST\n,\n \ntrue\n));\n\n\n        \n/**\n\n\n         * Define Plinker Config\n\n\n         */\n\n        \n$plinker\n \n=\n \n[\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n,\n\n            \n// optional config\n\n            \n/*\nconfig\n =\n [\n\n\n                // allowed ips, restrict access by ip\n\n\n                \nallowed_ips\n =\n [\n\n\n                    \n127.0.0.1\n\n\n                ]\n\n\n            ]*/\n\n        \n];\n\n\n        \n// init plinker server\n\n        \n$server\n \n=\n \nnew\n \n\\Plinker\\Core\\Server\n(\n\n            \n$_POST\n,\n\n            \n$plinker\n[\npublic_key\n],\n\n            \n$plinker\n[\nprivate_key\n],\n\n            \n(\narray\n)\n \n@\n$plinker\n[\nconfig\n]\n\n        \n);\n\n\n        \nexit\n(\n$server\n-\nexecute\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Files"
        }, 
        {
            "location": "/files/#making-remote-calls", 
            "text": "?php  require   ../../vendor/autoload.php ;  try   { \n\n     /**       * Plinker Config       */ \n     $config   =   [ \n         // plinker connection | using tasks as to write in the correct .sqlite file \n         plinker   =   [ \n             endpoint   =   http://127.0.0.1/examples/cron/server.php , \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp \n         ], \n\n         // optional config \n         config   =   [ \n             journal   =   ./crontab.journal , \n             apply     =   false \n         ] \n     ]; \n\n     // init plinker endpoint client \n     $cron   =   new   \\Plinker\\Core\\Client ( \n         // where is the plinker server \n         $config [ plinker ][ endpoint ], \n\n         // component namespace to interface to \n         Files\\Manager , \n\n         // keys \n         $config [ plinker ][ public_key ], \n         $config [ plinker ][ private_key ], \n\n         // construct array which you pass to the component \n         $config [ config ] \n     ); \n\n     // todo!  }   catch   ( \\Exception   $e )   { \n     exit ( get_class ( $e ) . :  . $e - getMessage ());  }   then the server part...  ?php  require   ../../vendor/autoload.php ;  /**   * Its POST..   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n\n     /**       * Its Plinker!       */ \n     if   ( isset ( $_SERVER [ HTTP_PLINKER ]))   { \n         // test its encrypted \n         file_put_contents ( ./.plinker/encryption-proof.txt ,   print_r ( $_POST ,   true )); \n\n         /**           * Define Plinker Config           */ \n         $plinker   =   [ \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp , \n             // optional config \n             /* config  =  [                  // allowed ips, restrict access by ip                   allowed_ips  =  [                       127.0.0.1                  ]              ]*/ \n         ]; \n\n         // init plinker server \n         $server   =   new   \\Plinker\\Core\\Server ( \n             $_POST , \n             $plinker [ public_key ], \n             $plinker [ private_key ], \n             ( array )   @ $plinker [ config ] \n         ); \n\n         exit ( $server - execute ()); \n     }  }   See the  organisations page  for additional components.", 
            "title": "Making remote calls."
        }, 
        {
            "location": "/iptables/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.\n\n\nWIP: control iptables though rpc\n\n\n::Installing::\n\n\nBring in the project with composer:\n\n\n{\n    \nrequire\n: {\n        \nplinker/iptables\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nThen navigate to \n./vendor/plinker/iptables/scripts\n and run \nbash install.sh\n\n\n::Client::\n\n\n/**\n\n\n * Plinker Config\n\n\n */\n\n\n$\nconfig\n \n=\n \n[\n\n\n    \n//\n \nplinker\n \nconnection\n\n\n    \nplinker\n \n=\n \n[\n\n\n        \nendpoint\n \n=\n \nhttp://127.0.0.1:88\n,\n\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n\n    \n]\n,\n\n\n\n    \n//\n \ndatabase\n \nconnection\n\n\n    \ndatabase\n \n=\n \n[\n\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n\n        \nhost\n     \n=\n \n,\n\n\n        \nname\n     \n=\n \n,\n\n\n        \nusername\n \n=\n \n,\n\n\n        \npassword\n \n=\n \n,\n\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n\n        \ndebug\n    \n=\n \nfalse\n,\n\n\n    \n]\n\n\n];\n\n\n\n//\n \ninit\n \nplinker\n \nendpoint\n \nclient\n\n\n$\niptables\n \n=\n \nnew\n \n\\\nPlinker\n\\\nCore\n\\\nClient\n(\n\n\n    \n//\n \nwhere\n \nis\n \nthe\n \nplinker\n \nserver\n\n\n    \n$\nconfig\n[\nplinker\n][\nendpoint\n]\n,\n\n\n\n    \n//\n \ncomponent\n \nnamespace\n \nto\n \ninterface\n \nto\n\n\n    \nIptables\\Manager\n,\n\n\n\n    \n//\n \nkeys\n\n\n    \n$\nconfig\n[\nplinker\n][\npublic_key\n]\n,\n\n\n    \n$\nconfig\n[\nplinker\n][\nprivate_key\n]\n,\n\n\n\n    \n//\n \nconstruct\n \nvalues\n \nwhich\n \nyou\n \npass\n \nto\n \nthe\n \ncomponent\n,\n \nwhich\n \nthe\n \ncomponent\n\n\n    \n//\n  \nwill\n \nuse\n,\n \nfor\n \nRedbeanPHP\n \ncomponent\n \nyou\n \nwould\n \nsend\n \nthe\n \ndatabase\n \nconnection\n\n\n    \n//\n  \ndont\n \nworry\n \nits\n \nAES\n \nencrypted\n.\n \nsee\n:\n \nencryption\n-\nproof\n.\ntxt\n\n\n    \n$\nconfig\n\n\n)\n;\n\n\n\n\n\n\n::Calls::\n\n\nSetup\n\n\nApplies build tasks to plinker/tasks queue.\n\n\n$iptables-\nsetup([\n    \nbuild_sleep\n =\n 5,\n    // LXD settings *required\n    \nlxd\n =\n [\n        \nbridge\n =\n \nlxdbr0\n,\n        \nip\n =\n \n10.158.250.0/24\n\n    ],\n    // Docker settings *optional\n    \ndocker\n =\n [\n        \nbridge\n =\n \ndocker0\n,\n        \nip\n =\n \n172.17.0.0/16\n\n    ]\n]);\n\n\n\n\n\nCreate\n\n\n$route = [\n    \nlabel\n =\n \nExample\n,\n    \ndomains\n =\n [\n        \nexample.com\n,\n        \nwww.example.com\n\n    ],\n    \nupstreams\n =\n [\n        [\nip\n =\n \n127.0.0.1\n, \nport\n =\n \n80\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n$iptables-\nadd($route);\n\n\n\n\n\nUpdate\n\n\n$route = [\n    \nlabel\n =\n \nExample Changed\n,\n    \ndomains\n =\n [\n        \nexample.com\n,\n        \nwww.example.com\n,\n        \nnew.example.com\n,\n    ],\n    \nupstreams\n =\n [\n        [\nip\n =\n 10.0.0.1\n, \nport\n =\n \n8080\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n// column, value, $data\n$iptables-\nupdate(\nid = ?\n, [1], $route);\n\n\n\n\n\nFetch\n\n\n$iptables-\nfetch(\nroute\n);\n$iptables-\nfetch(\nroute\n, \nid = ?\n, [1]);\n$iptables-\nfetch(\nroute\n, \nname = ?\n, [\nsome-guidV4-value\n])\n\n\n\n\n\nRemove\n\n\n$iptables-\nremove(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nRebuild\n\n\n$iptables-\nrebuild(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nReset\n\n\n// dont remove tasks\n$iptables-\nreset();\n\n// remove tasks\n$iptables-\nreset(true);\n\n\n\n\n\nSee the \norganisations page\n for additional \ncomponents and examples.", 
            "title": "Iptables"
        }, 
        {
            "location": "/iptables/#installing", 
            "text": "Bring in the project with composer:  {\n     require : {\n         plinker/iptables :  =v0.1 \n    }\n}  Then navigate to  ./vendor/plinker/iptables/scripts  and run  bash install.sh", 
            "title": "::Installing::"
        }, 
        {
            "location": "/iptables/#client", 
            "text": "/**   * Plinker Config   */  $ config   =   [       //   plinker   connection       plinker   =   [           endpoint   =   http://127.0.0.1:88 ,           public_key    =   makeSomethingUp ,           private_key   =   againMakeSomethingUp       ] ,       //   database   connection       database   =   [           dsn        =   sqlite:./.plinker/database.db ,           host       =   ,           name       =   ,           username   =   ,           password   =   ,           freeze     =   false ,           debug      =   false ,       ]  ];  //   init   plinker   endpoint   client  $ iptables   =   new   \\ Plinker \\ Core \\ Client (       //   where   is   the   plinker   server       $ config [ plinker ][ endpoint ] ,       //   component   namespace   to   interface   to       Iptables\\Manager ,       //   keys       $ config [ plinker ][ public_key ] ,       $ config [ plinker ][ private_key ] ,       //   construct   values   which   you   pass   to   the   component ,   which   the   component       //    will   use ,   for   RedbeanPHP   component   you   would   send   the   database   connection       //    dont   worry   its   AES   encrypted .   see :   encryption - proof . txt       $ config  ) ;", 
            "title": "::Client::"
        }, 
        {
            "location": "/iptables/#calls", 
            "text": "Setup  Applies build tasks to plinker/tasks queue.  $iptables- setup([\n     build_sleep  =  5,\n    // LXD settings *required\n     lxd  =  [\n         bridge  =   lxdbr0 ,\n         ip  =   10.158.250.0/24 \n    ],\n    // Docker settings *optional\n     docker  =  [\n         bridge  =   docker0 ,\n         ip  =   172.17.0.0/16 \n    ]\n]);  Create  $route = [\n     label  =   Example ,\n     domains  =  [\n         example.com ,\n         www.example.com \n    ],\n     upstreams  =  [\n        [ ip  =   127.0.0.1 ,  port  =   80 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n$iptables- add($route);  Update  $route = [\n     label  =   Example Changed ,\n     domains  =  [\n         example.com ,\n         www.example.com ,\n         new.example.com ,\n    ],\n     upstreams  =  [\n        [ ip  =  10.0.0.1 ,  port  =   8080 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n// column, value, $data\n$iptables- update( id = ? , [1], $route);  Fetch  $iptables- fetch( route );\n$iptables- fetch( route ,  id = ? , [1]);\n$iptables- fetch( route ,  name = ? , [ some-guidV4-value ])  Remove  $iptables- remove( name = ? , [$route[ name ]]);  Rebuild  $iptables- rebuild( name = ? , [$route[ name ]]);  Reset  // dont remove tasks\n$iptables- reset();\n\n// remove tasks\n$iptables- reset(true);  See the  organisations page  for additional \ncomponents and examples.", 
            "title": "::Calls::"
        }, 
        {
            "location": "/lxc/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nWIP: An older/deprecated component which controls LXC1.0 containers.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/lxc\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\nWIP: To be updated with info on how to use this component, also add the tasks code.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $url to host\n\n\n * @param string $component namespace of class to interface to\n\n\n * @param string $public_key to authenticate on host\n\n\n * @param string $private_key to authenticate on host\n\n\n * @param string $config component construct config\n\n\n */\n\n\n$plink\n \n=\n \nnew\n \nPlinker\\Core\\Client\n(\n\n    \nhttp://example.com\n,\n\n    \nTest\\Demo\n,\n\n    \nusername\n,\n\n    \npassword\n,\n\n    \narray\n(\n\n        \ntime\n \n=\n \ntime\n()\n\n    \n)\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$plink\n-\ntest\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Lxc"
        }, 
        {
            "location": "/lxc/#making-a-remote-call", 
            "text": "WIP: To be updated with info on how to use this component, also add the tasks code.  ?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $url to host   * @param string $component namespace of class to interface to   * @param string $public_key to authenticate on host   * @param string $private_key to authenticate on host   * @param string $config component construct config   */  $plink   =   new   Plinker\\Core\\Client ( \n     http://example.com , \n     Test\\Demo , \n     username , \n     password , \n     array ( \n         time   =   time () \n     )  );  echo   pre . print_r ( $plink - test (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/nginx/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP \ncomponent classes on remote systems, while maintaining the feel of a local \nmethod call.\n\n\nThe aim of this component is to build web forwards/reverse proxy to LXD/LXC \ncontainers on the host (or external upstreams), not as a \nserver{}\n block configurator.\n\n\nThe component uses nginx as a reverse proxy, it relies on php7-fpm being \ninstalled and will overwrite \n/etc/nginx/nginx.conf\n! So if you already have\nnginx installed then dont use this component as it will most likely break your stuff.\n\n\n::Installing::\n\n\nBring in the project with composer:\n\n\n{\n    \nrequire\n: {\n        \nplinker/nginx\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nThen navigate to \n./vendor/plinker/nginx/scripts\n and run \nbash install.sh\n\n\nThe webroot for plinker will be \n/var/www/html\n so plinker should be in there.\nThe difference being that nginx will listen on port 88 for plinker calls, \nand 80, 443 for the reverse proxy.\n\n\n::Client::\n\n\n/**\n\n\n * Plinker Config\n\n\n */\n\n\n$\nconfig\n \n=\n \n[\n\n\n    \n//\n \nplinker\n \nconnection\n\n\n    \nplinker\n \n=\n \n[\n\n\n        \nendpoint\n \n=\n \nhttp://127.0.0.1:88\n,\n\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n\n    \n]\n,\n\n\n\n    \n//\n \ndatabase\n \nconnection\n\n\n    \ndatabase\n \n=\n \n[\n\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n\n        \nhost\n     \n=\n \n,\n\n\n        \nname\n     \n=\n \n,\n\n\n        \nusername\n \n=\n \n,\n\n\n        \npassword\n \n=\n \n,\n\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n\n        \ndebug\n    \n=\n \nfalse\n,\n\n\n    \n]\n\n\n];\n\n\n\n//\n \ninit\n \nplinker\n \nendpoint\n \nclient\n\n\n$\nnginx\n \n=\n \nnew\n \n\\\nPlinker\n\\\nCore\n\\\nClient\n(\n\n\n    \n//\n \nwhere\n \nis\n \nthe\n \nplinker\n \nserver\n\n\n    \n$\nconfig\n[\nplinker\n][\nendpoint\n]\n,\n\n\n\n    \n//\n \ncomponent\n \nnamespace\n \nto\n \ninterface\n \nto\n\n\n    \nNginx\\Manager\n,\n\n\n\n    \n//\n \nkeys\n\n\n    \n$\nconfig\n[\nplinker\n][\npublic_key\n]\n,\n\n\n    \n$\nconfig\n[\nplinker\n][\nprivate_key\n]\n,\n\n\n\n    \n//\n \nconstruct\n \nvalues\n \nwhich\n \nyou\n \npass\n \nto\n \nthe\n \ncomponent\n,\n \nwhich\n \nthe\n \ncomponent\n\n\n    \n//\n  \nwill\n \nuse\n,\n \nfor\n \nRedbeanPHP\n \ncomponent\n \nyou\n \nwould\n \nsend\n \nthe\n \ndatabase\n \nconnection\n\n\n    \n//\n  \ndont\n \nworry\n \nits\n \nAES\n \nencrypted\n.\n \nsee\n:\n \nencryption\n-\nproof\n.\ntxt\n\n\n    \n$\nconfig\n\n\n)\n;\n\n\n\n\n\n\n::Calls::\n\n\nSetup\n\n\nApplies build tasks to plinker/tasks queue.\n\n\n$nginx-\nsetup([\n    \nbuild_sleep\n =\n 1    \n])\n\n\n\n\n\nCreate\n\n\n$route = [\n    \nlabel\n =\n \nExample\n,\n    \nownDomain\n =\n [\n        [\nname\n =\n \nexample.com\n],\n        [\nname\n =\n \nwww.example.com\n]\n    ],\n    \nownUpstream\n =\n [\n        [\nip\n =\n \n127.0.0.1\n, \nport\n =\n \n80\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n$nginx-\nadd($route);\n\n\n\n\n\nUpdate\n\n\n$route = [\n    \nlabel\n =\n \nExample Changed\n,\n    \nownDomain\n =\n [\n        [\nname\n =\n \nexample.com\n],\n        [\nname\n =\n \nwww.example.com\n],\n        [\nname\n =\n \nnew.example.com\n]\n    ],\n    \nownUpstream\n =\n [\n        [\nip\n =\n 10.0.0.1\n, \nport\n =\n \n8080\n]\n    ],\n    \nletsencrypt\n =\n 0,\n    \nenabled\n =\n 1\n];\n// column, value, $data\n$nginx-\nupdate(\nid = ?\n, [1], $data);\n\n\n\n\n\nFetch\n\n\n$nginx-\nfetch(\nroute\n);\n$nginx-\nfetch(\nroute\n, \nid = ?\n, [1]);\n$nginx-\nfetch(\nroute\n, \nname = ?\n, [\nsome-guidV4-value\n])\n\n\n\n\n\nRemove\n\n\n$nginx-\nremove(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nRebuild\n\n\n$nginx-\nrebuild(\nname = ?\n, [$route[\nname\n]]);\n\n\n\n\n\nReset\n\n\n// dont remove tasks\n$nginx-\nreset();\n\n// remove tasks\n$nginx-\nreset(true);\n\n\n\n\n\nSee the \norganisations page\n for additional \ncomponents and examples.", 
            "title": "Nginx"
        }, 
        {
            "location": "/nginx/#installing", 
            "text": "Bring in the project with composer:  {\n     require : {\n         plinker/nginx :  =v0.1 \n    }\n}  Then navigate to  ./vendor/plinker/nginx/scripts  and run  bash install.sh  The webroot for plinker will be  /var/www/html  so plinker should be in there.\nThe difference being that nginx will listen on port 88 for plinker calls, \nand 80, 443 for the reverse proxy.", 
            "title": "::Installing::"
        }, 
        {
            "location": "/nginx/#client", 
            "text": "/**   * Plinker Config   */  $ config   =   [       //   plinker   connection       plinker   =   [           endpoint   =   http://127.0.0.1:88 ,           public_key    =   makeSomethingUp ,           private_key   =   againMakeSomethingUp       ] ,       //   database   connection       database   =   [           dsn        =   sqlite:./.plinker/database.db ,           host       =   ,           name       =   ,           username   =   ,           password   =   ,           freeze     =   false ,           debug      =   false ,       ]  ];  //   init   plinker   endpoint   client  $ nginx   =   new   \\ Plinker \\ Core \\ Client (       //   where   is   the   plinker   server       $ config [ plinker ][ endpoint ] ,       //   component   namespace   to   interface   to       Nginx\\Manager ,       //   keys       $ config [ plinker ][ public_key ] ,       $ config [ plinker ][ private_key ] ,       //   construct   values   which   you   pass   to   the   component ,   which   the   component       //    will   use ,   for   RedbeanPHP   component   you   would   send   the   database   connection       //    dont   worry   its   AES   encrypted .   see :   encryption - proof . txt       $ config  ) ;", 
            "title": "::Client::"
        }, 
        {
            "location": "/nginx/#calls", 
            "text": "Setup  Applies build tasks to plinker/tasks queue.  $nginx- setup([\n     build_sleep  =  1    \n])  Create  $route = [\n     label  =   Example ,\n     ownDomain  =  [\n        [ name  =   example.com ],\n        [ name  =   www.example.com ]\n    ],\n     ownUpstream  =  [\n        [ ip  =   127.0.0.1 ,  port  =   80 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n$nginx- add($route);  Update  $route = [\n     label  =   Example Changed ,\n     ownDomain  =  [\n        [ name  =   example.com ],\n        [ name  =   www.example.com ],\n        [ name  =   new.example.com ]\n    ],\n     ownUpstream  =  [\n        [ ip  =  10.0.0.1 ,  port  =   8080 ]\n    ],\n     letsencrypt  =  0,\n     enabled  =  1\n];\n// column, value, $data\n$nginx- update( id = ? , [1], $data);  Fetch  $nginx- fetch( route );\n$nginx- fetch( route ,  id = ? , [1]);\n$nginx- fetch( route ,  name = ? , [ some-guidV4-value ])  Remove  $nginx- remove( name = ? , [$route[ name ]]);  Rebuild  $nginx- rebuild( name = ? , [$route[ name ]]);  Reset  // dont remove tasks\n$nginx- reset();\n\n// remove tasks\n$nginx- reset(true);  See the  organisations page  for additional \ncomponents and examples.", 
            "title": "::Calls::"
        }, 
        {
            "location": "/redbean/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nRedBeanPHP component which will enable you to directly manage databases on remote sites.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/redbean\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\ntry\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$config\n \n=\n \n[\n\n        \n// plinker connection | using tasks as to write in the correct .sqlite file\n\n        \nplinker\n \n=\n \n[\n\n            \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/redbean/server.php\n,\n\n            \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n            \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n        \n],\n\n\n        \n// database connection\n\n        \ndatabase\n \n=\n \n[\n\n            \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n            \nhost\n     \n=\n \n,\n\n            \nname\n     \n=\n \n,\n\n            \nusername\n \n=\n \n,\n\n            \npassword\n \n=\n \n,\n\n            \nfreeze\n   \n=\n \nfalse\n,\n\n            \ndebug\n    \n=\n \nfalse\n,\n\n        \n]\n\n    \n];\n\n\n    \n// init plinker endpoint client\n\n    \n$rdb\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n        \n// where is the plinker server\n\n        \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n        \n// component namespace to interface to\n\n        \nRedbean\\Redbean\n,\n\n\n        \n// keys\n\n        \n$config\n[\nplinker\n][\npublic_key\n],\n\n        \n$config\n[\nplinker\n][\nprivate_key\n],\n\n\n        \n// construct values which you pass to the component\n\n        \n$config\n[\ndatabase\n]\n\n    \n);\n\n\n    \n//..\n\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nexit\n(\nget_class\n(\n$e\n)\n.\n: \n.\n$e\n-\ngetMessage\n());\n\n\n}\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Redbean"
        }, 
        {
            "location": "/redbean/#making-a-remote-call", 
            "text": "?php  require   vendor/autoload.php ;  try   { \n\n     /**       * Plinker Config       */ \n     $config   =   [ \n         // plinker connection | using tasks as to write in the correct .sqlite file \n         plinker   =   [ \n             endpoint   =   http://127.0.0.1/examples/redbean/server.php , \n             public_key    =   makeSomethingUp , \n             private_key   =   againMakeSomethingUp \n         ], \n\n         // database connection \n         database   =   [ \n             dsn        =   sqlite:./.plinker/database.db , \n             host       =   , \n             name       =   , \n             username   =   , \n             password   =   , \n             freeze     =   false , \n             debug      =   false , \n         ] \n     ]; \n\n     // init plinker endpoint client \n     $rdb   =   new   \\Plinker\\Core\\Client ( \n         // where is the plinker server \n         $config [ plinker ][ endpoint ], \n\n         // component namespace to interface to \n         Redbean\\Redbean , \n\n         // keys \n         $config [ plinker ][ public_key ], \n         $config [ plinker ][ private_key ], \n\n         // construct values which you pass to the component \n         $config [ database ] \n     ); \n\n     //..  }   catch   ( \\Exception   $e )   { \n     exit ( get_class ( $e ) . :  . $e - getMessage ());  }   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/system/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA system component which gives you access to server information.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/system\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $server\n\n\n * @param string $config\n\n\n */\n\n\n$client\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \nhttp://example.com/server.php\n,\n\n    \n[\n\n        \nsecret\n \n=\n \na secret password\n\n    \n]\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$client\n-\nsystem\n-\nmemory_stats\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "System"
        }, 
        {
            "location": "/system/#making-a-remote-call", 
            "text": "?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $server   * @param string $config   */  $client   =   new   \\Plinker\\Core\\Client ( \n     http://example.com/server.php , \n     [ \n         secret   =   a secret password \n     ]  );  echo   pre . print_r ( $client - system - memory_stats (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/tasks/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nThe tasks component allows you to write code based tasks which are completed by a daemon, \nthis could allow you to create a single interface to control a cluster of servers tasks.\n\n\nWant to see an example project? Check out \nPlinkerUI\n.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/tasks\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nExample source\n\n\nYou should create a file which will be run via cron, for example:\n\n\ncron.php\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/*\n\n\n * The cron job\n\n\n *\n\n\n * @reboot while sleep 1; do cd /var/www/html/examples/tasks \n /usr/bin/php run.php ; done\n\n\n */\n\n\n\nif\n \n(\nphp_sapi_name\n()\n \n!=\n \ncli\n)\n \n{\n\n    \nheader\n(\nHTTP/1.0 403 Forbidden\n);\n\n    \nexit\n(\nCLI script\n);\n\n\n}\n\n\n\n$task\n \n=\n \nnew\n \nPlinker\\Tasks\\Runner\n([\n\n    \ndatabase\n \n=\n \n[\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n        \nhost\n     \n=\n \n,\n\n        \nname\n     \n=\n \n,\n\n        \nusername\n \n=\n \n,\n\n        \npassword\n \n=\n \n,\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n        \ndebug\n    \n=\n \nfalse\n\n    \n],\n\n    \ndebug\n       \n=\n \ntrue\n,\n\n    \nlog\n         \n=\n \ntrue\n,\n\n    \nsleep_time\n  \n=\n \n2\n,\n\n    \ntmp_path\n    \n=\n \n./.plinker\n,\n\n    \nauto_update\n \n=\n \n86400\n\n\n]);\n\n\n\n$task\n-\ndaemon\n(\nQueue\n);\n\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Plinker Config\n\n\n */\n\n\n$config\n \n=\n \n[\n\n    \n// plinker connection\n\n    \nplinker\n \n=\n \n[\n\n        \nendpoint\n \n=\n \nhttp://127.0.0.1/examples/tasks/server.php\n,\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n    \n],\n\n\n    \n// database connection\n\n    \ndatabase\n \n=\n \n[\n\n        \ndsn\n      \n=\n \nsqlite:./.plinker/database.db\n,\n\n        \nhost\n     \n=\n \n,\n\n        \nname\n     \n=\n \n,\n\n        \nusername\n \n=\n \n,\n\n        \npassword\n \n=\n \n,\n\n        \nfreeze\n   \n=\n \nfalse\n,\n\n        \ndebug\n    \n=\n \nfalse\n,\n\n    \n],\n\n\n    \n// displays output to task runner console\n\n    \ndebug\n \n=\n \ntrue\n,\n\n\n    \n// daemon sleep time\n\n    \nsleep_time\n \n=\n \n1\n,\n\n    \ntmp_path\n   \n=\n \n./.plinker\n\n\n];\n\n\n\n// init plinker client\n\n\n$tasks\n \n=\n \nnew\n \n\\Plinker\\Core\\Client\n(\n\n    \n// where is the plinker server\n\n    \n$config\n[\nplinker\n][\nendpoint\n],\n\n\n    \n// component namespace to interface to\n\n    \nTasks\\Manager\n,\n\n\n    \n// keys\n\n    \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$config\n[\nplinker\n][\npublic_key\n]),\n\n    \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$config\n[\nplinker\n][\nprivate_key\n]),\n\n\n    \n// construct values which you pass to the component, which the component\n\n    \n//  will use, for RedbeanPHP component you would send the database connection\n\n    \n//  dont worry its AES encrypted. see: encryption-proof.txt\n\n    \n$config\n\n\n);\n\n\n\n/**\n\n\n * Example\n\n\n */\n\n\n\n// create the task\n\n\ntry\n \n{\n\n    \n// create task\n\n    \n$tasks\n-\ncreate\n(\n\n        \n// name\n\n        \nHello World\n,\n\n        \n// source\n\n        \n?php echo \nHello World\n;\n,\n\n        \n// type\n\n        \nphp\n,\n\n        \n// description\n\n        \n...\n,\n\n        \n// default params\n\n        \n[]\n\n    \n);\n\n\n}\n \ncatch\n \n(\n\\Exception\n \n$e\n)\n \n{\n\n    \nif\n \n(\n$e\n-\ngetMessage\n()\n \n==\n \nUnauthorised\n)\n \n{\n\n        \necho\n \nError: Connected successfully but could not authenticate! Check public and private keys.\n;\n\n    \n}\n \nelse\n \n{\n\n        \necho\n \nError:\n.\nstr_replace\n(\nCould not unserialize response:\n,\n \n,\n \ntrim\n(\nhtmlentities\n(\n$e\n-\ngetMessage\n())));\n\n    \n}\n\n\n}\n\n\n\n//run task now - executed as apache user\n\n\n//print_r($tasks-\nrunNow(\nHello World\n));\n\n\n\n// place task in queue to run\n\n\nprint_r\n(\n$tasks\n-\nrun\n(\nHello World\n,\n \n[\n1\n],\n \n5\n));\n\n\n\n// get task status\n\n\nprint_r\n(\n$tasks\n-\nstatus\n(\nHello World\n));\n\n\n\n// get task run count\n\n\nprint_r\n(\n$tasks\n-\nrunCount\n(\nHello World\n));\n\n\n\n// clear all tasks\n\n\n//$tasks-\nclear();\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \n../../vendor/autoload.php\n;\n\n\n\n/**\n\n\n * Plinker Server\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n\n    \n/**\n\n\n     * Plinker Config\n\n\n     */\n\n    \n$plinker\n \n=\n \n[\n\n        \npublic_key\n  \n=\n \nmakeSomethingUp\n,\n\n        \nprivate_key\n \n=\n \nagainMakeSomethingUp\n\n    \n];\n\n\n    \n/**\n\n\n     * Plinker server listener\n\n\n     */\n\n    \nif\n \n(\nisset\n(\n$_POST\n[\ndata\n])\n \n\n        \nisset\n(\n$_POST\n[\ntoken\n])\n \n\n        \nisset\n(\n$_POST\n[\npublic_key\n])\n\n    \n)\n \n{\n\n        \n// test its encrypted\n\n        \nfile_put_contents\n(\n./.plinker/encryption-proof.txt\n,\n \nprint_r\n(\n$_POST\n,\n \ntrue\n));\n\n\n        \n//\n\n        \n$server\n \n=\n \nnew\n \n\\Plinker\\Core\\Server\n(\n\n            \n$_POST\n,\n\n            \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$plinker\n[\npublic_key\n]),\n\n            \nhash\n(\nsha256\n,\n \ngmdate\n(\nh\n)\n.\n$plinker\n[\nprivate_key\n])\n\n        \n);\n\n\n        \nexit\n(\n$server\n-\nexecute\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components and examples.", 
            "title": "Tasks"
        }, 
        {
            "location": "/tasks/#making-a-remote-call", 
            "text": "?php  require   ../../vendor/autoload.php ;  /**   * Plinker Config   */  $config   =   [ \n     // plinker connection \n     plinker   =   [ \n         endpoint   =   http://127.0.0.1/examples/tasks/server.php , \n         public_key    =   makeSomethingUp , \n         private_key   =   againMakeSomethingUp \n     ], \n\n     // database connection \n     database   =   [ \n         dsn        =   sqlite:./.plinker/database.db , \n         host       =   , \n         name       =   , \n         username   =   , \n         password   =   , \n         freeze     =   false , \n         debug      =   false , \n     ], \n\n     // displays output to task runner console \n     debug   =   true , \n\n     // daemon sleep time \n     sleep_time   =   1 , \n     tmp_path     =   ./.plinker  ];  // init plinker client  $tasks   =   new   \\Plinker\\Core\\Client ( \n     // where is the plinker server \n     $config [ plinker ][ endpoint ], \n\n     // component namespace to interface to \n     Tasks\\Manager , \n\n     // keys \n     hash ( sha256 ,   gmdate ( h ) . $config [ plinker ][ public_key ]), \n     hash ( sha256 ,   gmdate ( h ) . $config [ plinker ][ private_key ]), \n\n     // construct values which you pass to the component, which the component \n     //  will use, for RedbeanPHP component you would send the database connection \n     //  dont worry its AES encrypted. see: encryption-proof.txt \n     $config  );  /**   * Example   */  // create the task  try   { \n     // create task \n     $tasks - create ( \n         // name \n         Hello World , \n         // source \n         ?php echo  Hello World ; , \n         // type \n         php , \n         // description \n         ... , \n         // default params \n         [] \n     );  }   catch   ( \\Exception   $e )   { \n     if   ( $e - getMessage ()   ==   Unauthorised )   { \n         echo   Error: Connected successfully but could not authenticate! Check public and private keys. ; \n     }   else   { \n         echo   Error: . str_replace ( Could not unserialize response: ,   ,   trim ( htmlentities ( $e - getMessage ()))); \n     }  }  //run task now - executed as apache user  //print_r($tasks- runNow( Hello World ));  // place task in queue to run  print_r ( $tasks - run ( Hello World ,   [ 1 ],   5 ));  // get task status  print_r ( $tasks - status ( Hello World ));  // get task run count  print_r ( $tasks - runCount ( Hello World ));  // clear all tasks  //$tasks- clear();   then the server part...  ?php  require   ../../vendor/autoload.php ;  /**   * Plinker Server   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n\n     /**       * Plinker Config       */ \n     $plinker   =   [ \n         public_key    =   makeSomethingUp , \n         private_key   =   againMakeSomethingUp \n     ]; \n\n     /**       * Plinker server listener       */ \n     if   ( isset ( $_POST [ data ])   \n         isset ( $_POST [ token ])   \n         isset ( $_POST [ public_key ]) \n     )   { \n         // test its encrypted \n         file_put_contents ( ./.plinker/encryption-proof.txt ,   print_r ( $_POST ,   true )); \n\n         // \n         $server   =   new   \\Plinker\\Core\\Server ( \n             $_POST , \n             hash ( sha256 ,   gmdate ( h ) . $plinker [ public_key ]), \n             hash ( sha256 ,   gmdate ( h ) . $plinker [ private_key ]) \n         ); \n\n         exit ( $server - execute ()); \n     }  }   See the  organisations page  for additional components and examples.", 
            "title": "Making a remote call."
        }, 
        {
            "location": "/test/", 
            "text": "PlinkerRPC PHP client/server makes it really easy to link and execute PHP component classes on remote systems, while maintaining the feel of a local method call.\n\n\nA Test component which simply returns back what you sent, for testing/example purposes.\n\n\nComposer\n\n\n{\n    \nrequire\n: {\n        \nplinker/core\n: \n=v0.1\n,\n        \nplinker/test\n: \n=v0.1\n\n    }\n}\n\n\n\n\n\nMaking a remote call.\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * Initialize plinker client.\n\n\n *\n\n\n * @param string $url to host\n\n\n * @param string $component namespace of class to interface to\n\n\n * @param string $public_key to authenticate on host\n\n\n * @param string $private_key to authenticate on host\n\n\n * @param string $config component construct config\n\n\n */\n\n\n$plink\n \n=\n \nnew\n \nPlinker\\Core\\Client\n(\n\n    \nhttp://example.com\n,\n\n    \nTest\\Demo\n,\n\n    \nusername\n,\n\n    \npassword\n,\n\n    \narray\n(\n\n        \ntime\n \n=\n \ntime\n()\n\n    \n)\n\n\n);\n\n\necho\n \npre\n.\nprint_r\n(\n$plink\n-\ntest\n(),\n \ntrue\n)\n.\n/pre\n;\n\n\n\n\n\n\nthen the server part...\n\n\n?php\n\n\nrequire\n \nvendor/autoload.php\n;\n\n\n\n/**\n\n\n * POST Server Part\n\n\n */\n\n\nif\n \n(\n$_SERVER\n[\nREQUEST_METHOD\n]\n \n==\n \nPOST\n)\n \n{\n\n    \n$server\n \n=\n \nnew\n \nPlinker\\Core\\Server\n(\n\n        \n$_POST\n,\n\n        \nusername\n,\n\n        \npassword\n\n    \n);\n\n    \nexit\n(\n$server\n-\nexecute\n());\n\n\n}\n\n\n\n\n\n\nSee the \norganisations page\n for additional components.", 
            "title": "Test"
        }, 
        {
            "location": "/test/#making-a-remote-call", 
            "text": "?php  require   vendor/autoload.php ;  /**   * Initialize plinker client.   *   * @param string $url to host   * @param string $component namespace of class to interface to   * @param string $public_key to authenticate on host   * @param string $private_key to authenticate on host   * @param string $config component construct config   */  $plink   =   new   Plinker\\Core\\Client ( \n     http://example.com , \n     Test\\Demo , \n     username , \n     password , \n     array ( \n         time   =   time () \n     )  );  echo   pre . print_r ( $plink - test (),   true ) . /pre ;   then the server part...  ?php  require   vendor/autoload.php ;  /**   * POST Server Part   */  if   ( $_SERVER [ REQUEST_METHOD ]   ==   POST )   { \n     $server   =   new   Plinker\\Core\\Server ( \n         $_POST , \n         username , \n         password \n     ); \n     exit ( $server - execute ());  }   See the  organisations page  for additional components.", 
            "title": "Making a remote call."
        }
    ]
}